// ConsoleApplication3.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"
#include <iostream>
using namespace std;

int main()
{
	size_t pi[5];
	prefix_find("qwecvfbgnwqevcqwertqwesdgvfsgyjqwr", "qwert", pi);
	return 0;
}
// пример функции обработки, которая выводит индекс начала найденного образца
int f(size_t i)
{
	cout << i;
	printf("%d\n", i);
	return 1;
}
// str строка поиска.
// obr образец, который ищем.
// pi массив длин префиксов для образца (минимум  сколько символов в образце).
// int f(size_t i) когда образец найден, вызывается эта функция, 
// ей передается индекс начала найденного в str образца.
// функция возвращает 0, если надо прекратить поиск и 1, если надо продолжить.
void prefix_find(char *str, char *obr, size_t *pi)//, int(*f)(size_t))
{
	pi[0] = 0;     // в i-м элементе (его индекс i-1) количество совпавших 
				   // символов в начале образца и в конце подстроки длины i. 
				   // p[0]=0 всегда, p[1]=1, если начинается с двух одинаковых 
	size_t l;    // будет длина образца
				 // заполняем массив длин префиксов для образца
	for (l = 1; obr[l]; ++l)
	{
		size_t j = pi[l - 1];
		while ((j > 0) && (obr[l] != obr[j])) // не равны
			j = pi[j - 1];	         // берем ранее рассчитанное значение (начиная с максимально возможных)
		if (obr[l] == obr[j])      // равны 
			++j;
		pi[l] = j;
	}
	size_t j = 0; // количество совпавших символов, оно же индекс сравниваемого 
				  // символа в образце. В строке сравниваемый символ будет иметь индекс i
	for (size_t i = 0; str[i]; ++i)
	{
		while ((j > 0) && (str[i] != obr[j]))
			// Очередной символ строки не совпал с символом в образце. Сдвигаем образец, 
			// причем точно знаем, что первые j символов образца совпали с символами строки 
			// и надо сравнить j+1й символ образца (его индекс j) с i+1м символом строки.
			j = pi[j - 1];    // если j=0, то достигли начала образца и цикл следует прервать

		if (str[i] == obr[j]) // есть совпадение очередного символа 
			++j;              // увеличиваем длину совпавшего фрагмента на 1
		if (j == l)
			if (!f(i - l + 1)) // образец найден, вызовем функцию обработки
				return;  // и выйдем из процедуры, если она вернет 0. 
	}
}

